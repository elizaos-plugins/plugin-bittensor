{"version":3,"sources":["../src/index.ts","../src/actions/sn34.ts","../src/evaluators/fact.ts","../src/providers/time.ts","../src/actions/index.ts","../src/evaluators/index.ts","../src/providers/index.ts"],"sourcesContent":["import type { Plugin } from \"@elizaos/core\";\nimport { TwitterClientInterface } from \"@elizaos/client-twitter\";\n\nimport { analyzeImage, analysisHistory } from \"./actions/sn34.ts\";\nimport { factEvaluator } from \"./evaluators/fact.ts\";\nimport { timeProvider } from \"./providers/time.ts\";\n\nexport * as actions from \"./actions/index.ts\";\nexport * as evaluators from \"./evaluators/index.ts\";\nexport * as providers from \"./providers/index.ts\";\n\n\nexport const bittensorPlugin: Plugin = {\n    name: \"bittensor\",\n    description: \"Utilize the BitMind API to access a range of digital commodities, including inference, media generation, and deepfake detection, on Bittensor's decentralized AI network.\",\n    actions: [\n        analyzeImage,\n        analysisHistory\n    ],\n    evaluators: [factEvaluator],\n    providers: [timeProvider],\n    clients: [TwitterClientInterface]\n};\nexport default bittensorPlugin;","import {\n    ActionExample,\n    IAgentRuntime,\n    Memory,\n    State,\n    HandlerCallback,\n    type Action,\n} from \"@elizaos/core\";\nimport { elizaLogger } from \"@elizaos/core\";\n\ninterface AIImageDetectionResult {\n    isAIGenerated: boolean;\n    confidenceScore: number;\n}\n\ninterface AIImageAnalysisMemory extends Memory {\n    content: {\n        text: string;\n        imageUrl: string;\n        isAIGenerated: boolean;\n        confidenceScore: number;\n        imageSource: 'tweet' | 'url';\n        actionType: string;\n    };\n}\n\nexport const formatAnalysisHistory = (analyses: AIImageAnalysisMemory[]) => {\n    const analysisStrings = analyses\n        .reverse()\n        .map((analysis: AIImageAnalysisMemory) => {\n            const { isAIGenerated, confidenceScore } = analysis.content;\n            const scorePercentage = Number(confidenceScore);\n            return `Image Analysis: ${isAIGenerated ? 'AI Generated' : 'Natural'} (${(scorePercentage * 100).toFixed(2)}% confidence)`;\n        });\n    return analysisStrings.join(\"\\n\");\n};\n\nconst validateAnalysisRequest = async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {\n    elizaLogger.info(\"ðŸ” BitMind: Validating analysis request...\");\n    \n    const urlMatch = message?.content?.text?.match(/https?:\\/\\/[^\\s]+/);\n    const imageUrls = message?.content?.imageUrls as string[] | undefined;\n\n    if (!urlMatch && (!imageUrls || imageUrls.length === 0)) {\n        elizaLogger.error(\"âŒ BitMind: No image URL found in request\");\n        return false;\n    }\n\n    if (!runtime?.character?.settings?.secrets?.BITMIND) {\n        elizaLogger.error(\"âŒ BitMind: API credentials not configured\");\n        return false;\n    }\n\n    elizaLogger.info(\"âœ… BitMind: Request validation successful\");\n    return true;\n};\n\nconst extractImageUrl = (message: Memory): { url: string; isTweet: boolean } => {\n    const urlMatch = message.content.text.match(/https?:\\/\\/[^\\s]+/);\n    const imageUrls = message.content.imageUrls as string[] | undefined;\n    const isTweet = Boolean(imageUrls && imageUrls.length > 0);\n\n    if (isTweet && imageUrls) {\n        return { url: imageUrls[0], isTweet };\n    } \n    if (urlMatch) {\n        return { url: urlMatch[0], isTweet };\n    }\n    throw new Error(\"No valid image URL found in request\");\n};\n\nconst analyzeImageWithBitMind = async (imageUrl: string, apiKey: string): Promise<AIImageDetectionResult> => {\n    try {\n        const response = await fetch(\"https://subnet-api.bitmindlabs.ai/detect-image\", {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": `Bearer ${apiKey}`,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({ image: imageUrl })\n        });\n\n        if (!response.ok) {\n            const errorMessage = `BitMind API error (${response.status}): ${response.statusText}`;\n            elizaLogger.error(`âŒ ${errorMessage}`);\n            if (response.status === 500) {\n                throw new Error(\"BitMind service is currently experiencing issues. Please try again later.\");\n            }\n            throw new Error(errorMessage);\n        }\n\n        const result = await response.json();\n        return {\n            isAIGenerated: result.isAI,\n            confidenceScore: result.confidence\n        };\n    } catch (error) {\n        if (error.message.includes('BitMind service')) {\n            throw error; // Re-throw our custom error\n        }\n        elizaLogger.error('âŒ BitMind API request failed:', error);\n        throw new Error('Failed to connect to BitMind service. Please check your connection and try again.');\n    }\n};\n\nconst generateAnalysisReport = (result: AIImageDetectionResult): string => {\n    const confidencePercent = (result.confidenceScore * 100).toFixed(2);\n    const confidenceValue = parseFloat(confidencePercent);\n    \n    return `ðŸ” Trinity Matrix Deepfake Analysis\nPowered by BitMind Subnet (SN34) on Bittensor\n\n${result.isAIGenerated ? 'ðŸ¤– AI Generated' : 'ðŸ“¸ Natural Image'}\n${confidencePercent}% AI Influence Rating\n${confidenceValue > 75 \n    ? \"âš ï¸ High synthetic probability detected. Approach with caution.\" \n    : confidenceValue > 40 \n        ? \"âš¡ Moderate AI patterns present. Verification recommended.\" \n        : \"âœ… Low synthetic markers. Likely authentic content.\"}\n\nâ€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”`;\n};\n\nexport const analyzeImage: Action = {\n    name: \"DETECT_IMAGE\",\n    similes: [\"ANALYZE_IMAGE\", \"VERIFY_IMAGE\", \"BITMIND_DETECTION\", \"AI_DETECTION\", \"REAL_OR_FAKE\"],\n    validate: validateAnalysisRequest,\n    description: \"Analyze an image to determine if it was AI-generated using BitMind API\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback: HandlerCallback\n    ): Promise<void> => {\n        if (state['isAnalysisInProgress']) return;\n        state['isAnalysisInProgress'] = true;\n\n        elizaLogger.info(\"ðŸ¤– BitMind: Initiating image analysis...\");\n        \n        if (!runtime.character?.settings?.secrets?.BITMIND) {\n            throw new Error(\"BitMind API credentials not configured\");\n        }\n\n        try {\n            const { url: imageUrl, isTweet } = extractImageUrl(message);\n            elizaLogger.info(`ðŸ“¸ BitMind: Processing image: ${imageUrl}`);\n\n            const result = await analyzeImageWithBitMind(imageUrl, runtime.character.settings.secrets.BITMIND);\n\n            elizaLogger.info(`âœ… BitMind: Analysis complete`, {\n                isAIGenerated: result.isAIGenerated,\n                confidenceScore: result.confidenceScore,\n                source: isTweet ? 'tweet' : 'message'\n            });\n\n            const analysisMemory: AIImageAnalysisMemory = {\n                ...message,\n                content: {\n                    text: `Image Analysis: ${result.isAIGenerated ? 'AI Generated' : 'Natural'} (${(result.confidenceScore * 100).toFixed(2)}% confidence)`,\n                    imageUrl: imageUrl,\n                    isAIGenerated: result.isAIGenerated,\n                    confidenceScore: result.confidenceScore,\n                    imageSource: isTweet ? 'tweet' : 'url',\n                    actionType: \"DETECT_IMAGE\"\n                },\n                createdAt: Date.now(),\n            };\n\n            elizaLogger.info(\"Saving analysis memory:\", {\n                roomId: message.roomId,\n                analysisMemory\n            });\n\n            await runtime.messageManager.createMemory(analysisMemory);\n            \n            elizaLogger.info(\"Analysis memory saved\");\n\n            callback({\n                text: generateAnalysisReport(result),\n                isAIGenerated: result.isAIGenerated,\n                confidenceScore: result.confidenceScore\n            });\n\n        } catch (error) {\n            elizaLogger.error(`âŒ BitMind: Analysis error:`, error);\n            throw new Error(`Image analysis failed: ${error.message}`);\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"analyze this image: https://example.com/image.jpg\" }\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"I'll analyze that image for you...\",\n                    action: \"DETECT_IMAGE\"\n                }\n            }\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"is this image AI generated?\" }\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"Let me check if that image is AI generated...\",\n                    action: \"DETECT_IMAGE\"\n                }\n            }\n        ]\n    ] as ActionExample[][],\n} as Action;\n\nconst generateConfidenceBar = (confidence: number): string => {\n    const barLength = 20;\n    const filledBars = Math.round(confidence * barLength);\n    const emptyBars = barLength - filledBars;\n    return `[${'â–ˆ'.repeat(filledBars)}${'â–‘'.repeat(emptyBars)}]`;\n};\n\nexport const analysisHistory: Action = {\n    name: \"IMAGE_REPORT\",\n    similes: [\"SHOW_DETECTIONS\", \"IMAGE_HISTORY\", \"PAST_ANALYSES\", \"DETECTION_HISTORY\"],\n    validate: async (runtime: IAgentRuntime): Promise<boolean> => {\n        return true;\n    },\n    description: \"Display history of AI image analysis results\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback: HandlerCallback\n    ): Promise<void> => {\n        elizaLogger.info(\"ðŸ“Š BitMind: Generating analysis history...\");\n        try {\n            const limit = options?.limit || 10;\n        \n            // Get all rooms the agent is in\n            const rooms = await runtime.databaseAdapter.getRoomsForParticipant(runtime.agentId);\n            elizaLogger.info(`ðŸ“Š BitMind: Found ${rooms.length} rooms`);\n    \n            // Get memories from each room and combine them\n            const allMemories = await runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: rooms,\n                limit: limit * 5\n            }) as AIImageAnalysisMemory[];\n    \n            elizaLogger.info(`ðŸ“Š BitMind: Retrieved ${allMemories.length} memories`);\n    \n            const imageAnalyses = allMemories.filter(\n                mem => mem.content.actionType === 'DETECT_IMAGE'\n            );\n\n            elizaLogger.info(`ðŸ“Š BitMind: Found ${imageAnalyses.length} image analyses`);\n\n            if (!imageAnalyses || imageAnalyses.length === 0) {\n                callback({\n                    text: \"No image analyses found.\",\n                });\n                return;\n            }\n            const statistics = imageAnalyses.reduce((acc, analysis) => {\n                acc.total++;\n                if (analysis.content.isAIGenerated) acc.aiCount++;\n                acc.avgConfidence += analysis.content.confidenceScore;\n                return acc;\n            }, { total: 0, aiCount: 0, avgConfidence: 0 });\n\n            const reportText = `ðŸ” Trinity Matrix Analysis Report\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nðŸ“Š Recent Analyses (${imageAnalyses.length})\n${formatAnalysisHistory(imageAnalyses)}\n\nðŸ“ˆ Statistical Overview\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ðŸ” Total Analyzed : ${statistics.total.toString().padEnd(12)} â”‚\nâ”‚ ðŸ¤– AI Generated  : ${statistics.aiCount.toString().padEnd(12)} â”‚\nâ”‚ ðŸ“¸ Natural       : ${(statistics.total - statistics.aiCount).toString().padEnd(12)} â”‚\nâ”‚ âš¡ AI Detection Rate: ${((statistics.aiCount / statistics.total) * 100).toFixed(1)}%      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nðŸŽ¯ Confidence Metrics\nAverage Confidence: ${((statistics.avgConfidence / statistics.total) * 100).toFixed(1)}%\n${generateConfidenceBar(statistics.avgConfidence / statistics.total)}\n\nPowered by BitMind Subnet (SN34) on Bittensor`;\n\n            callback({ text: reportText });\n\n        } catch (error) {\n            elizaLogger.error(`âŒ BitMind: History generation error:`, error);\n            throw new Error(`Failed to generate analysis history: ${error.message}`);\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"show me recent image analyses\" }\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"Here's your image analysis report...\",\n                    action: \"IMAGE_REPORT\"\n                }\n            }\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"what images have you checked recently?\" }\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"Let me show you the recent image detection history...\",\n                    action: \"IMAGE_REPORT\"\n                }\n            }\n        ]\n    ] as ActionExample[][],\n} as Action;","import { composeContext } from \"@elizaos/core\";\nimport { generateObjectArray } from \"@elizaos/core\";\nimport { MemoryManager } from \"@elizaos/core\";\nimport {\n    type ActionExample,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type Evaluator,\n} from \"@elizaos/core\";\n\nexport const formatFacts = (facts: Memory[]) => {\n    const messageStrings = facts\n        .reverse()\n        .map((fact: Memory) => fact.content.text);\n    const finalMessageStrings = messageStrings.join(\"\\n\");\n    return finalMessageStrings;\n};\n\nconst factsTemplate =\n    // {{actors}}\n    `TASK: Extract Claims from the conversation as an array of claims in JSON format.\n\n# START OF EXAMPLES\nThese are an examples of the expected output of this task:\n{{evaluationExamples}}\n# END OF EXAMPLES\n\n# INSTRUCTIONS\n\nExtract any claims from the conversation that are not already present in the list of known facts above:\n- Try not to include already-known facts. If you think a fact is already known, but you're not sure, respond with already_known: true.\n- If the fact is already in the user's description, set in_bio to true\n- If we've already extracted this fact, set already_known to true\n- Set the claim type to 'status', 'fact' or 'opinion'\n- For true facts about the world or the character that do not change, set the claim type to 'fact'\n- For facts that are true but change over time, set the claim type to 'status'\n- For non-facts, set the type to 'opinion'\n- 'opinion' inlcudes non-factual opinions and also includes the character's thoughts, feelings, judgments or recommendations\n- Include any factual detail, including where the user lives, works, or goes to school, what they do for a living, their hobbies, and any other relevant information\n\nRecent Messages:\n{{recentMessages}}\n\nResponse should be a JSON object array inside a JSON markdown block. Correct response format:\n\\`\\`\\`json\n[\n  {\"claim\": string, \"type\": enum<fact|opinion|status>, in_bio: boolean, already_known: boolean },\n  {\"claim\": string, \"type\": enum<fact|opinion|status>, in_bio: boolean, already_known: boolean },\n  ...\n]\n\\`\\`\\``;\n\nasync function handler(runtime: IAgentRuntime, message: Memory) {\n    const state = await runtime.composeState(message);\n\n    const { agentId, roomId } = state;\n\n    const context = composeContext({\n        state,\n        template: runtime.character.templates?.factsTemplate || factsTemplate,\n    });\n\n    const facts = await generateObjectArray({\n        runtime,\n        context,\n        modelClass: ModelClass.LARGE,\n    });\n\n    const factsManager = new MemoryManager({\n        runtime,\n        tableName: \"facts\",\n    });\n\n    if (!facts) {\n        return [];\n    }\n\n    // If the fact is known or corrupted, remove it\n    const filteredFacts = facts\n        .filter((fact) => {\n            return (\n                !fact.already_known &&\n                fact.type === \"fact\" &&\n                !fact.in_bio &&\n                fact.claim &&\n                fact.claim.trim() !== \"\"\n            );\n        })\n        .map((fact) => fact.claim);\n\n    if (!agentId) {\n        return filteredFacts;\n    }\n\n    for (const fact of filteredFacts) {\n        const factMemory = await factsManager.addEmbeddingToMemory({\n            userId: agentId,\n            agentId,\n            content: { text: fact },\n            roomId,\n            createdAt: Date.now(),\n        });\n\n        await factsManager.createMemory(factMemory, true);\n\n        await new Promise((resolve) => setTimeout(resolve, 250));\n    }\n    return filteredFacts;\n}\n\nexport const factEvaluator: Evaluator = {\n    name: \"GET_FACTS\",\n    similes: [\n        \"GET_CLAIMS\",\n        \"EXTRACT_CLAIMS\",\n        \"EXTRACT_FACTS\",\n        \"EXTRACT_CLAIM\",\n        \"EXTRACT_INFORMATION\",\n    ],\n    validate: async (\n        runtime: IAgentRuntime,\n\n        message: Memory\n    ): Promise<boolean> => {\n        const messageCount = (await runtime.messageManager.countMemories(\n            message.roomId\n        )) as number;\n\n        const reflectionCount = Math.ceil(runtime.getConversationLength() / 2);\n\n        return messageCount % reflectionCount === 0;\n    },\n    description:\n        \"Extract factual information about the people in the conversation, the current events in the world, and anything else that might be important to remember.\",\n    handler,\n    examples: [\n        {\n            context: `Actors in the scene:\n{{user1}}: Programmer and moderator of the local story club.\n{{user2}}: New member of the club. Likes to write and read.\n\nFacts about the actors:\nNone`,\n            messages: [\n                {\n                    user: \"{{user1}}\",\n                    content: { text: \"So where are you from\" },\n                },\n                {\n                    user: \"{{user2}}\",\n                    content: { text: \"I'm from the city\" },\n                },\n                {\n                    user: \"{{user1}}\",\n                    content: { text: \"Which city?\" },\n                },\n                {\n                    user: \"{{user2}}\",\n                    content: { text: \"Oakland\" },\n                },\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"Oh, I've never been there, but I know it's in California\",\n                    },\n                },\n            ] as ActionExample[],\n            outcome: `{ \"claim\": \"{{user2}} is from Oakland\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": false },`,\n        },\n        {\n            context: `Actors in the scene:\n{{user1}}: Athelete and cyclist. Worked out every day for a year to prepare for a marathon.\n{{user2}}: Likes to go to the beach and shop.\n\nFacts about the actors:\n{{user1}} and {{user2}} are talking about the marathon\n{{user1}} and {{user2}} have just started dating`,\n            messages: [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"I finally completed the marathon this year!\",\n                    },\n                },\n                {\n                    user: \"{{user2}}\",\n                    content: { text: \"Wow! How long did it take?\" },\n                },\n                {\n                    user: \"{{user1}}\",\n                    content: { text: \"A little over three hours.\" },\n                },\n                {\n                    user: \"{{user1}}\",\n                    content: { text: \"I'm so proud of myself.\" },\n                },\n            ] as ActionExample[],\n            outcome: `Claims:\njson\\`\\`\\`\n[\n  { \"claim\": \"Alex just completed a marathon in just under 4 hours.\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": false },\n  { \"claim\": \"Alex worked out 2 hours a day at the gym for a year.\", \"type\": \"fact\", \"in_bio\": true, \"already_known\": false },\n  { \"claim\": \"Alex is really proud of himself.\", \"type\": \"opinion\", \"in_bio\": false, \"already_known\": false }\n]\n\\`\\`\\`\n`,\n        },\n        {\n            context: `Actors in the scene:\n{{user1}}: Likes to play poker and go to the park. Friends with Eva.\n{{user2}}: Also likes to play poker. Likes to write and read.\n\nFacts about the actors:\nMike and Eva won a regional poker tournament about six months ago\nMike is married to Alex\nEva studied Philosophy before switching to Computer Science`,\n            messages: [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"Remember when we won the regional poker tournament last spring\",\n                    },\n                },\n                {\n                    user: \"{{user2}}\",\n                    content: {\n                        text: \"That was one of the best days of my life\",\n                    },\n                },\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"It really put our poker club on the map\",\n                    },\n                },\n            ] as ActionExample[],\n            outcome: `Claims:\njson\\`\\`\\`\n[\n  { \"claim\": \"Mike and Eva won the regional poker tournament last spring\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": true },\n  { \"claim\": \"Winning the regional poker tournament put the poker club on the map\", \"type\": \"opinion\", \"in_bio\": false, \"already_known\": false }\n]\n\\`\\`\\``,\n        },\n    ],\n};\n","import type { IAgentRuntime, Memory, Provider, State } from \"@elizaos/core\";\n\nconst timeProvider: Provider = {\n    get: async (_runtime: IAgentRuntime, _message: Memory, _state?: State) => {\n        const currentDate = new Date();\n\n        // Get UTC time since bots will be communicating with users around the global\n        const options = {\n            timeZone: \"UTC\",\n            dateStyle: \"full\" as const,\n            timeStyle: \"long\" as const,\n        };\n        const humanReadable = new Intl.DateTimeFormat(\"en-US\", options).format(\n            currentDate\n        );\n        return `The current date and time is ${humanReadable}. Please use this as your reference for any time-based operations or responses.`;\n    },\n};\nexport { timeProvider };\n","export * from \"./sn34.ts\";","export * from \"./fact.ts\";","export * from \"./time.ts\";"],"mappings":"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","names":[]}